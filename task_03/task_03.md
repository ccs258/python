# 1、异常处理的必要性

通常在程序中，异常不止是包含程序运算爆出的异常，而是包括任何用户、系统输入、输出引发的异常。

- 增加代码的鲁棒性

  开发人员在写代码的过程中，可以专注实现代码的主逻辑，对于一些未知的异常可以使用异常处理跳过，这样主逻辑不会被中断，仍能正常执行。

- 方便对异常情况做判断处理，要么忽略，要么抛出异常。

  对于一些上级调用者认为需要处理的异常类型，可以事先增加对某种异常的判断，这样触发该异常后，可以根据实际场景忽略，要么raise抛出异常，这样方便上级调用者对这种触发情况做进一步处理。

  

# 2、异常处理的经典实现

先看一个最经典的try...except...else...finally异常处理实现：

case1：未触发异常Demo

```
def test_try_except():
    try:
        print("执行try语句！")
    except Exception:
        print("执行Exception语句！")
    else:
        print("异常未发生时执行else语句！")
    finally:
        print("最终执行finally语句！")

if __name__ == '__main__':
    print("函数开始运行！")
    test_try_except()
    print("函数运行结束！")
    
结果输出：
############################################
函数开始运行！
执行try语句！
异常未发生时执行else语句！
最终执行finally语句！
函数运行结束！
############################################


```

case2：触发异常Demo



```
def test_try_except_02():
    try:
        2/0
        print("执行try语句！")
    except Exception:
        print("执行Exception语句！")
    else:
        print("异常未发生时执行else语句！")
    finally:
        print("最终执行finally语句！")
if __name__ == '__main__':
    print("函数开始运行！")
    test_try_except_02()
    print("函数运行结束！")        

结果输出：
############################################
函数开始运行！
执行try语句！
异常未发生时执行else语句！
最终执行finally语句！
函数运行结束！
############################################
```



从上面的demo可以看出，对于try...except...else...finally异常处理框架而言：

对于case1,如果未触发异常，则程序会执行try、else、finally中的程序；

对于case2,如果触发异常，则程序会执行try、exception、finally中的程序；

可以看出，异常处理的运行机制为：程序会先按照运行顺序先执行try中的语句，如果突try中的语句未触发异常即正常执行，则下面会跳转到else处执行；如果try中有程序触发了异常（例如：case2中分母为0的异常）则会跳转到exception中执行；但不管是否有程序触发异常，最终都会执行finally中的语句，这点通常可以应用在实际中对某些实现进行监控：比如判断循环是异常发生导致的结束还是正常遍历完结束。整理成流程图如下：



![img](https://pics6.baidu.com/feed/fc1f4134970a304e3707a578a0fea483c8175cc1.jpeg?token=e29352eeaf61fc7ae2592094d833a57f&s=B5B0EF37091A46CA12DD547B03007077)



# 3、异常处理的应用场景

- 连接某些服务或者读取文件时，可添加异常处理，方便重试。

  比如：连接数据库时，对于连接异常的处理；读取某些文件时，对是否文件存在时做异常处理；还有比如说调用消息队列/交易中间件/其他web service，这些情况下如果不处理异常，你会看到各种诡异的业务表现。

- 在程序的处理逻辑中，对不确定性进行异常兼容处理

  比如：在数据库中，对数据执行特定SQL语句的处理。或者对于一些用户输入的场景，比如输入账户登录，可以用异常处理来进行用户输入的不合法的响应。

  

# 4、异常处理的注意事项

- 明确异常处理的作用是为了暴露问题，而不是掩盖问题。

  当处理代码中可能出现的异常，我们不能为了虚伪的健壮性而盲目掩盖所有的异常。当代码的执行无法从异常中恢复，我们应该如实去向调用者汇报异常；这时候我们能做的只是确保抛出的异常能够让调用者准确理解错误，并执行相应的业务错误处理逻辑。

  因此建议捕获异常的代码需要指定具体的异常类型，而不能捕获通用异常（catch general exception）。错误不能及早发现，它可能会带来更严重的后果，或者让我们更难调试问题的原因。比如遇到应用启动初始化的异常，我们往往需要阻止应用成功启动，而不是任由应用正常启动，否则错误的初始化下的应用可能会做出一些我们难以理解的行为。

- 对于错误项，选择合适的异常项。

  一般而言，错误处理是业务领域知识，异常处理是编程语言领域知识。前者关注的业务领域模型，后者关注的是如何使用对象和对象间的关系去表达前者。因此，了解业务知识可以帮助我们更准确地判断应当使用什么粒度层次的异常项，以准确表达业务错误。



# 5、作业题

1、猜数字游戏

题目描述:

电脑产生一个零到100之间的随机数字，然后让用户来猜，如果用户猜的数字比这个数字大，提示太大，否则提示太小，当用户正好猜中电脑会提示，"恭喜你猜到了这个数是......"。在用户每次猜测之前程序会输出用户是第几次猜测，如果用户输入的根本不是一个数字，程序会告诉用户"输入无效"。

(尝试使用try catch异常处理结构对输入情况进行处理)

获取随机数采用random模块

代码实现：

```
import random
count=1
x=random.randint(0,100)
print("猜测一个0到100之间的整数：\n")
while True:
    try:
        m = input("这是第%d次猜，请输入一个整数：\n" % count)
        m1=int(m)
        if m1>x:
            print("太大")
            count +=1
            #continue

        elif m1<x:
            print("太小")
            count += 1
            #continue
        else:
            print("恭喜你猜对了！")
            count=1
            x=random.randint(0,100)
            print("猜测一个0到100之间的整数：\n")
    except ValueError as error:
        print("输入的不是数字" + str(error))
        print("请输入一个0到100之间的整数")
```



# 6、参考

什么情况下使用异常处理？：https://www.zhihu.com/question/27122172?sort=created

总结Python编程中遇到的无数个“坑”（异常处理的正确过程）：https://baijiahao.baidu.com/s?id=1636646977338815546&wfr=spider&for=pc

理解业务错误才能做好异常处理：https://xw.qq.com/cmsid/20200724A0WWV700